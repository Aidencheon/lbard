#!/bin/bash

# Tests for Serval LBARD
#
# Copyright 2016 Serval Project, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

source "${0%/*}/../serval-dna/testframework.sh"
source "${0%/*}/../testdefs.sh"

lbard_console() {
   local C="$instance_name"
   executeOk --executable="lbard"  --stdout-file="${C}_LBARDOUT" --stderr-file="${C}_LBARDERR" $*
   tfw_cat --stdout --stderr
}

fork_lbard_console() {
   local C="$instance_name"
   fork %lbard$C lbard_console "$*"
}

setup() {
   # Configure four servald daemons without any interfaces connecting them, and
   # start them running.
   setup_servald
   assert_no_servald_processes
   foreach_instance +A +B +C +D create_single_identity

   # Create files in each servald instance if requested
   if [ "x$2" != "x" ]; then
       common_files=$2
       for ((n = 0; n < $files_per_instance; ++n)); do
	   set_instance +A
           create_file file-common-${n} 10000
	   echo -e "service=File\nsender=$SIDA\nrecipient=$SIDB" >file$n.manifest
	   executeOk_servald rhizome add file $SIDA file-common-${n} file${n}.manifest
	   extract_manifest_id BID file${n}.manifest
	   extract_manifest_version VERSION file${n}.manifest
	   executeOk_servald rhizome export bundle $BID file${n}e.manifest file${n}e
	   for i in B C D
	   do
	       set_instance +B
	       executeOk_servald rhizome import bundle file1e file1e.manifest	       
	   done
       done
       
   fi
   if [ "x$3" != "x" ]; then
       files_per_instance=$3       
       for i in A B C D
       do
	   set_instance +$i
	   local sidvar="SID$instance_name"
	   for ((n = 0; n < $files_per_instance; ++n)); do
               create_file file-$i-$n 10000
               tfw_quietly executeOk_servald rhizome add file "${!sidvar}" file-$i-$n file-$i-$n.manifest	   
	   done
       done
   fi
   
   foreach_instance +A +B +C +D start_servald_server
   get_servald_restful_http_server_port PORTA +A
   get_servald_restful_http_server_port PORTB +B
   get_servald_restful_http_server_port PORTC +C
   get_servald_restful_http_server_port PORTD +D
   # Start the fake radio daemon.
   fork %fakeradio fakecsmaradio rfd900,rfd900,rfd900,rfd900 ttys.txt "$1"
   wait_until --timeout=15 eval [ '$(cat ttys.txt | wc -l)' -ge 4 ]
   tty1=$(sed -n 1p ttys.txt)
   tty2=$(sed -n 2p ttys.txt)
   tty3=$(sed -n 3p ttys.txt)
   tty4=$(sed -n 4p ttys.txt)
   
   # Start four lbard daemons.
   set_instance +A
   fork_lbard_console "$addr_localhost:$PORTA" lbard:lbard "$SIDA" "$tty1" announce pull
   set_instance +B
   fork_lbard_console "$addr_localhost:$PORTB" lbard:lbard "$SIDB" "$tty2" pull
   set_instance +C
   fork_lbard_console "$addr_localhost:$PORTC" lbard:lbard "$SIDC" "$tty3" pull
   set_instance +D
   fork_lbard_console "$addr_localhost:$PORTD" lbard:lbard "$SIDD" "$tty4" pull
}

setup20() {
   # Configure four servald daemons without any interfaces connecting them, and
   # start them running.
   setup_servald
   assert_no_servald_processes
   foreach_instance +A +B +C +D +E +F +G +H +I +J +K +L +M +N +O +P +Q +R +S +T create_single_identity
   foreach_instance +A +B +C +D +E +F +G +H +I +J +K +L +M +N +O +P +Q +R +S +T start_servald_server
   get_servald_restful_http_server_port PORTA +A
   get_servald_restful_http_server_port PORTB +B
   get_servald_restful_http_server_port PORTC +C
   get_servald_restful_http_server_port PORTD +D
   get_servald_restful_http_server_port PORTE +E
   get_servald_restful_http_server_port PORTF +F
   get_servald_restful_http_server_port PORTG +G
   get_servald_restful_http_server_port PORTH +H
   get_servald_restful_http_server_port PORTI +I
   get_servald_restful_http_server_port PORTJ +J
   get_servald_restful_http_server_port PORTK +K
   get_servald_restful_http_server_port PORTL +L
   get_servald_restful_http_server_port PORTM +M
   get_servald_restful_http_server_port PORTN +N
   get_servald_restful_http_server_port PORTO +O
   get_servald_restful_http_server_port PORTP +P
   get_servald_restful_http_server_port PORTQ +Q
   get_servald_restful_http_server_port PORTR +R
   get_servald_restful_http_server_port PORTS +S
   get_servald_restful_http_server_port PORTT +T
   # Start the fake radio daemon.
   fork %fakeradio fakecsmaradio rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900,rfd900 ttys.txt "$1"
   wait_until --timeout=15 eval [ '$(cat ttys.txt | wc -l)' -ge 20 ]
   tty1=$(sed -n 1p ttys.txt)
   tty2=$(sed -n 2p ttys.txt)
   tty3=$(sed -n 3p ttys.txt)
   tty4=$(sed -n 4p ttys.txt)
   tty5=$(sed -n 5p ttys.txt)
   tty6=$(sed -n 6p ttys.txt)
   tty7=$(sed -n 7p ttys.txt)
   tty8=$(sed -n 8p ttys.txt)
   tty9=$(sed -n 9p ttys.txt)
   tty10=$(sed -n 10p ttys.txt)
   tty11=$(sed -n 11p ttys.txt)
   tty12=$(sed -n 12p ttys.txt)
   tty13=$(sed -n 13p ttys.txt)
   tty14=$(sed -n 14p ttys.txt)
   tty15=$(sed -n 15p ttys.txt)
   tty16=$(sed -n 16p ttys.txt)
   tty17=$(sed -n 17p ttys.txt)
   tty18=$(sed -n 18p ttys.txt)
   tty19=$(sed -n 19p ttys.txt)
   tty20=$(sed -n 20p ttys.txt)
   # Start four lbard daemons.
   fork %lbardA lbard "$addr_localhost:$PORTA" lbard:lbard "$SIDA" "$tty1" announce pull
   fork %lbardB lbard "$addr_localhost:$PORTB" lbard:lbard "$SIDB" "$tty2" pull
   fork %lbardC lbard "$addr_localhost:$PORTC" lbard:lbard "$SIDC" "$tty3" pull
   fork %lbardD lbard "$addr_localhost:$PORTD" lbard:lbard "$SIDD" "$tty4" pull
   fork %lbardE lbard "$addr_localhost:$PORTE" lbard:lbard "$SIDE" "$tty5" pull
   fork %lbardF lbard "$addr_localhost:$PORTF" lbard:lbard "$SIDF" "$tty6" pull
   fork %lbardG lbard "$addr_localhost:$PORTG" lbard:lbard "$SIDG" "$tty7" pull
   fork %lbardH lbard "$addr_localhost:$PORTH" lbard:lbard "$SIDH" "$tty8" pull
   fork %lbardI lbard "$addr_localhost:$PORTI" lbard:lbard "$SIDI" "$tty9" pull
   fork %lbardJ lbard "$addr_localhost:$PORTJ" lbard:lbard "$SIDJ" "$tty10" pull
   fork %lbardK lbard "$addr_localhost:$PORTK" lbard:lbard "$SIDK" "$tty11" pull
   fork %lbardL lbard "$addr_localhost:$PORTL" lbard:lbard "$SIDL" "$tty12" pull
   fork %lbardM lbard "$addr_localhost:$PORTM" lbard:lbard "$SIDM" "$tty13" pull
   fork %lbardN lbard "$addr_localhost:$PORTN" lbard:lbard "$SIDN" "$tty14" pull
   fork %lbardO lbard "$addr_localhost:$PORTO" lbard:lbard "$SIDO" "$tty15" pull
   fork %lbardP lbard "$addr_localhost:$PORTP" lbard:lbard "$SIDP" "$tty16" pull
   fork %lbardQ lbard "$addr_localhost:$PORTQ" lbard:lbard "$SIDQ" "$tty17" pull
   fork %lbardR lbard "$addr_localhost:$PORTR" lbard:lbard "$SIDR" "$tty18" pull
   fork %lbardS lbard "$addr_localhost:$PORTS" lbard:lbard "$SIDS" "$tty19" pull
   fork %lbardT lbard "$addr_localhost:$PORTT" lbard:lbard "$SIDT" "$tty20" pull
}

configure_servald_server() {
   # Do not configure any network interfaces.
   executeOk_servald config \
      set rhizome.http.enable 1 \
      set api.restful.users.lbard.password lbard
}

teardown() {
   stop_all_servald_servers
   kill_all_servald_processes
   assert_no_servald_processes
   report_all_servald_servers
}

doc_DetectRadios="LBARD detects radios"
setup_DetectRadios() {
   setup_servald
   assert_no_servald_processes
   foreach_instance +A +B +C +D create_single_identity
   foreach_instance +A +B +C +D start_servald_server
   get_servald_restful_http_server_port PORTA +A
   get_servald_restful_http_server_port PORTB +B
   get_servald_restful_http_server_port PORTC +C
   get_servald_restful_http_server_port PORTD +D
   # Start the fake radio daemon.
   fork %fakeradio fakecsmaradio rfd900,hfcodan,hfbarrett,rfd900 ttys.txt "$1"
   wait_until --timeout=15 eval [ '$(cat ttys.txt | wc -l)' -ge 4 ]
   tty1=$(sed -n 1p ttys.txt)
   tty2=$(sed -n 2p ttys.txt)
   tty3=$(sed -n 3p ttys.txt)
   tty4=$(sed -n 4p ttys.txt)
   # Start four lbard daemons.
   set_instance +A
   fork_lbard_console "$addr_localhost:$PORTA" lbard:lbard "$SIDA" "$tty1" pull
   set_instance +B
   fork_lbard_console "$addr_localhost:$PORTB" lbard:lbard "$SIDB" "$tty2" pull
   set_instance +C
   fork_lbard_console "$addr_localhost:$PORTC" lbard:lbard "$SIDC" "$tty3" pull
   set_instance +D
   fork_lbard_console "$addr_localhost:$PORTD" lbard:lbard "$SIDD" "$tty4" pull
}
test_DetectRadios() {
   # Test that all radios are detected
   wait_until --timeout=10 grep "No HF radio detected, assuming RFD900 series radio" A_LBARDERR
   wait_until --timeout=10 grep "Codan HF Radio running CICS" B_LBARDERR
   wait_until --timeout=10 grep "Detected Barrett HF Radio" C_LBARDERR
   wait_until --timeout=10 grep "No HF radio detected, assuming RFD900 series radio" D_LBARDERR

   fork_terminate %lbardA %lbardB %lbardC %lbardD 
   fork_terminate_all
}



doc_One="A single very small bundle transfers to 3 peers"
setup_One() {
   setup
   # Insert a file to server A
   set_instance +A
   rhizome_add_file file1 50
}
test_One() {
   # Test that the bundle arrives at servers B, C and D
   all_bundles_received() {
      bundle_received_by $BID:$VERSION +B &&
         bundle_received_by $BID:$VERSION +C &&
         bundle_received_by $BID:$VERSION +D
   }
   wait_until all_bundles_received
}

doc_One20="A single very small bundle transfers to 19 peers"
setup_One20() {
   setup20
   # Insert a file to server A
   set_instance +A
   rhizome_add_file file1 50
}
test_One20() {
   # Test that the bundle arrives at servers B - T
   all_bundles_received() {
      bundle_received_by $BID:$VERSION +B &&
         bundle_received_by $BID:$VERSION +C &&
         bundle_received_by $BID:$VERSION +D &&
         bundle_received_by $BID:$VERSION +E &&
         bundle_received_by $BID:$VERSION +F &&
         bundle_received_by $BID:$VERSION +G &&
         bundle_received_by $BID:$VERSION +H &&
         bundle_received_by $BID:$VERSION +I &&
         bundle_received_by $BID:$VERSION +J &&
         bundle_received_by $BID:$VERSION +K &&
         bundle_received_by $BID:$VERSION +L &&
         bundle_received_by $BID:$VERSION +M &&
         bundle_received_by $BID:$VERSION +N &&
         bundle_received_by $BID:$VERSION +O &&
         bundle_received_by $BID:$VERSION +P &&
         bundle_received_by $BID:$VERSION +Q &&
         bundle_received_by $BID:$VERSION +R &&
         bundle_received_by $BID:$VERSION +S &&
         bundle_received_by $BID:$VERSION +T
   }
   wait_until all_bundles_received
}

# ~150 bytes / sec * 50 seconds = ~9KB possible, less a bit for time redirecting around already received parts. 
# XXX - If we made senders realise when they are already sending the same bundle to someone else, and use the
# same offsets, we could obtain higher efficiency in transfer, and also reduce the number of segments during
# reception.
# For now, we have to be conservative, and just try 5KB in one minute.
doc_One2K="A single 2KB bundle transfers to peers"
setup_One2K() {
   setup
   # Insert a file to server A
   set_instance +A
   rhizome_add_file file1 2048
}
test_One2K() {
   # Test that the bundle arrives at servers B, C and D
   all_bundles_received() {
      bundle_received_by $BID:$VERSION +B &&
         bundle_received_by $BID:$VERSION +C &&
         bundle_received_by $BID:$VERSION +D
   }
   wait_until all_bundles_received
}

doc_TwoSenders="A single bundle is offered by two senders"
setup_TwoSenders() {
   setup
   # Insert a file to server A
   set_instance +A
   echo "Clear Text" >file1
   echo -e "service=File\nsender=$SIDA\nrecipient=$SIDB" >file1.manifest
   executeOk_servald rhizome add file $SIDA file1 file1.manifest
   extract_manifest_id BID file1.manifest
   extract_manifest_version VERSION file1.manifest
   executeOk_servald rhizome export bundle $BID file1e.manifest file1e
   set_instance +B
   executeOk_servald rhizome import bundle file1e file1e.manifest
}
test_TwoSenders() {
   # Test that the bundle arrives at servers B, C and D
   all_bundles_received() {
         bundle_received_by $BID:$VERSION +C &&
         bundle_received_by $BID:$VERSION +D
   }
   wait_until all_bundles_received
}

rhizome_add_file_to_many() {
    local name="$1"
    shift
    local size="$1"
    shift
    local first_instance="$1"
    shift
    set_instance "+$first_instance"
    rhizome_add_file "$name" "$size"
    # BID is in $BID from the above

    # Now insert on each
    replicate_bundle $BID $*

    }

replicate_bundle() {
    local BID=$1
    shift
    executeOk_servald rhizome export bundle $BID file1e.manifest file1e
    extract_manifest_version VERSION file1e.manifest
    while [ x"$1" != "x" ]; do	
	set_instance +$1
	executeOk_servald rhizome import bundle file1e file1e.manifest
	shift
    done
}


doc_TwoSendersCombined="A bundle can be received by combining pieces from different senders"
setup_TwoSendersCombined() {
   setup "drop manifest from 0; drop body from 1;"
   # Insert a file on server A and B
   rhizome_add_file_to_many "test" 50 A B
   BID=`echo $BID | cut -f1 -d:`
}
test_TwoSendersCombined() {
   # Test that the bundle arrives at servers B, C and D
   all_bundles_received() {
         bundle_received_by $BID:$VERSION +C &&
         bundle_received_by $BID:$VERSION +D
   }
   wait_until all_bundles_received
}

doc_TenSendersCombined="Ten receivers receive 6KB bundle from 10 senders in <1 minute"
setup_TenSendersCombined() {
   setup20
   # Insert a file on server A - J
   # Make file too big to be sent in 60 seconds by only one server
   # 60 sec * 200 bytes / sec = 12000 bytes
   # (reduce to 75% since we have ten receivers)
   rhizome_add_file_to_many "test" 6000 A B C D E F G H I J 
   BID=`echo $BID | cut -f1 -d:`
}
test_TenSendersCombined() {
   # Test that the bundle arrives at server K
   all_bundles_received() {
         bundle_received_by $BID:$VERSION +K &&
         bundle_received_by $BID:$VERSION +L &&
         bundle_received_by $BID:$VERSION +M &&
         bundle_received_by $BID:$VERSION +N &&
         bundle_received_by $BID:$VERSION +O &&
         bundle_received_by $BID:$VERSION +P &&
         bundle_received_by $BID:$VERSION +Q &&
         bundle_received_by $BID:$VERSION +R &&
         bundle_received_by $BID:$VERSION +S &&
         bundle_received_by $BID:$VERSION +T
   }
   wait_until all_bundles_received
}

doc_NTenSendersCombined="One receiver receives a 16KB bundle from 19 senders in <1 minute"
setup_NTenSendersCombined() {
   setup20
   # Insert a file on server A - J
   # Make file too big to be sent in 60 seconds by only one server
   # 60 sec * 200 bytes / sec = 12000 bytes
   # (reduce to 75% since we have ten receivers)
   rhizome_add_file_to_many "test" 16384 A B C D E F G H I J K L M N O P Q R S
   BID=`echo $BID | cut -f1 -d:`
}
test_NTenSendersCombined() {
   # Test that the bundle arrives at server T
   all_bundles_received() {
         bundle_received_by $BID:$VERSION +T
   }
   wait_until all_bundles_received
}


doc_All="All peers receive bundles from all other peers"
setup_All() {
   setup
   # Insert a file to server A
   set_instance +A
   rhizome_add_file file1 50
   BIDA=$BID
   VERSIONA=$VERSION
   # Insert a file to server B
   set_instance +B
   rhizome_add_file file2 51
   BIDB=$BID
   VERSIONB=$VERSION
   # Insert a file to server C
   set_instance +C
   rhizome_add_file file3 52
   BIDC=$BID
   VERSIONC=$VERSION
   # Insert a file to server D
   set_instance +D
   rhizome_add_file file4 53
   BIDD=$BID
   VERSIOND=$VERSION
}
test_All() {
   # Test that the bundle arrives at servers B, C and D
   all_bundles_received() {
      bundle_received_by $BIDA:$VERSIONA +B &&
      bundle_received_by $BIDA:$VERSIONA +C &&
      bundle_received_by $BIDA:$VERSIONA +D

      bundle_received_by $BIDB:$VERSIONB +A &&
      bundle_received_by $BIDB:$VERSIONB +C &&
      bundle_received_by $BIDB:$VERSIONB +D

      bundle_received_by $BIDC:$VERSIONC +A &&
      bundle_received_by $BIDC:$VERSIONC +B &&
      bundle_received_by $BIDC:$VERSIONC +D

      bundle_received_by $BIDD:$VERSIOND +A &&
      bundle_received_by $BIDD:$VERSIOND +B &&
      bundle_received_by $BIDD:$VERSIOND +C
   }
   wait_until all_bundles_received
}

doc_MessageDelivery="Send messages, ack and read them in a 2 party conversation via UHF"
setup_MessageDelivery() {
   setup "0"
}
test_MessageDelivery() {
   # 1. empty list
   set_instance +A
   executeOk_servald meshms list messages $SIDA $SIDB
   assertStdoutIs --stdout --line=1 -e '6\n'
   assertStdoutIs --stdout --line=2 -e '_id:my_offset:their_offset:age:type:message\n'
   assertStdoutLineCount '==' 2

   # 2. create a manifest with a single message, list it back and wait for delivery
   set_instance +A
   executeOk_servald meshms send message $SIDA $SIDB "Hi"
   executeOk_servald rhizome list
   b_receives_first_message() {
       set_instance +B
       executeOk_servald meshms list messages $SIDB $SIDA
       if ! grep ":<:Hi\$" $_tfw_tmp/stdout; then
	   return 1
       fi
   }   
   wait_until b_receives_first_message
   
   # 3. append a second message and list them both
   set_instance +A
   executeOk_servald meshms send message $SIDA $SIDB "How are you"
   executeOk_servald meshms list messages $SIDA $SIDB
   tfw_cat --stdout
   assertStdoutGrep --stdout --matches=1 ":>:How are you\$"
   assertStdoutGrep --stdout --matches=1 ":>:Hi\$"
   assertStdoutLineCount '==' 4
   
   # 4. list the messages from the receivers point of view (which ACKs them)
   b_receives_second_message() {
       set_instance +B
       executeOk_servald meshms list messages $SIDB $SIDA
       tfw_cat --stdout
       if ! egrep "^0:[0-9]+:[0-9]+:[0-9]+:<:How are you\$" $_tfw_tmp/stdout; then
	   return 1
       fi
       if ! egrep "^1:[0-9]+:[0-9]+:[0-9]+:<:Hi\$" $_tfw_tmp/stdout; then
	   return 1;
       fi
   }
   wait_until b_receives_second_message
   
   CONV_BID=$(replayStderr | sed -n -e '/MESHMS CONVERSATION BUNDLE/s/.*bid=\([0-9A-F]*\).*/\1/p')
   CONV_SECRET=$(replayStderr | sed -n -e '/MESHMS CONVERSATION BUNDLE/s/.*secret=\([0-9A-F]*\).*/\1/p')
   tfw_log "CONV_BID=$CONV_BID CONV_SECRET=$CONV_SECRET"
   
   # 5. mark the first message as read
   set_instance +B
   executeOk_servald meshms read messages $SIDB $SIDA 5
   tfw_cat --stderr
   executeOk_servald meshms list messages $SIDB $SIDA
   assertStdoutGrep --stdout --matches=1 ":<:How are you\$"
   assertStdoutEgrep --stdout --matches=1 ":5:[0-9]+:[0-9]+:MARK:read\$"
   assertStdoutGrep --stdout --matches=1 ":<:Hi\$"
   assertStdoutLineCount '==' 5
   
   # 6. mark all messages as read
   set_instance +B
   executeOk_servald meshms read messages $SIDB
   executeOk_servald meshms list messages $SIDB $SIDA
   assertStdoutEgrep --stdout --matches=1 "^0:25:[0-9]+:[0-9]+:MARK:read\$"
   assertStdoutEgrep --stdout --matches=1 "^1:[0-9]+:25:[0-9]+:<:How are you\$"
   assertStdoutEgrep --stdout --matches=1 "^2:[0-9]+:5:[0-9]+:<:Hi\$"
   assertStdoutLineCount '==' 5
   
   # 7. list messages from the senders point of view after they have been delivered
   a_receives_ACK_message() {
       set_instance +A
       executeOk_servald meshms list messages $SIDA $SIDB

       tfw_cat --stdout
       if ! egrep "^0:25:[0-9]+:[0-9]+:ACK:delivered\$" $_tfw_tmp/stdout; then
	   return 1;
       fi
       if ! egrep "^1:25:0:[0-9]+:>:How are you\$" $_tfw_tmp/stdout; then
	   return 1
       fi
       if ! egrep "^2:5:0:[0-9]+:>:Hi\$" $_tfw_tmp/stdout; then
	   return 1;
       fi
       assertStdoutLineCount '==' 5
   }
   wait_until a_receives_ACK_message
}

doc_MessageDeliveryLoss="Two party MeshMS conversation via UHF with 75% packet loss"
setup_MessageDeliveryLoss() {
   setup "0.75"
}
test_MessageDeliveryLoss() {
    test_MessageDelivery
}

doc_MessageDeliveryWithOthers="MeshMS conversation via UHF with other bundles held and 25% packet loss"
setup_MessageDeliveryWithOthers() {
    # 1500 files in common, 0 unique files per instance, 25% packet loss
   setup "0.25" 1500 0
}
test_MessageDeliveryWithOthers() {
    test_MessageDelivery
}

doc_MessageDeliveryWithTraffic="MeshMS conversation via UHF with other bundles in flight and 25% packet loss"
setup_MessageDeliveryWithTraffic() {
    # 1500 files in common, 0 unique files per instance, 25% packet loss
   setup "0.25" 1500 100
}
test_MessageDeliveryWithTraffic() {
    test_MessageDelivery
}

doc_MessageDeliveryThreeHops="MeshMS conversation via UHF, via two intermediate UHF hops"
setup_MessageDeliveryThreeHops() {
    # For simplicity the conversation is still from A->B, i.e., 0 to 1. Thus we route A->C->D->B and vice versa
    # We want to allow 0->3->2->1 only
   setup "allow between 0,3; allow between 3,2; allow between 2,1; deny all;"
}
test_MessageDeliveryThreeHops() {
    test_MessageDelivery
}


runTests "$@"
